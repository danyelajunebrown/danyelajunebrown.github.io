<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>STL Slicer Tool</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            line-height: 1.6;
        }
        h1 {
            color: #333;
            text-align: center;
        }
        .container {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        .upload-section {
            border: 2px dashed #ccc;
            padding: 20px;
            text-align: center;
            border-radius: 5px;
        }
        .upload-section:hover {
            border-color: #888;
        }
        .preview-container {
            display: flex;
            justify-content: space-between;
            flex-wrap: wrap;
            gap: 10px;
        }
        .preview-box {
            border: 1px solid #ddd;
            padding: 10px;
            border-radius: 5px;
            width: 48%;
            text-align: center;
            margin-bottom: 15px;
        }
        canvas {
            width: 100%;
            height: 200px;
            background-color: #f5f5f5;
        }
        button {
            padding: 10px 15px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
            margin-top: 10px;
        }
        button:hover {
            background-color: #45a049;
        }
        button:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
        }
        .download-all {
            text-align: center;
            margin-top: 20px;
        }
        .loading {
            display: none;
            text-align: center;
            margin: 20px 0;
        }
        .spinner {
            border: 4px solid rgba(0, 0, 0, 0.1);
            width: 36px;
            height: 36px;
            border-radius: 50%;
            border-left-color: #09f;
            animation: spin 1s linear infinite;
            display: inline-block;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        #error-message {
            color: red;
            text-align: center;
            margin: 10px 0;
            display: none;
        }
    </style>
</head>
<body>
    <h1>STL Slicer Tool</h1>
    <div class="container">
        <div class="upload-section" id="drop-area">
            <p>Drag and drop an STL file here or</p>
            <input type="file" id="file-input" accept=".stl">
            <button type="button" onclick="document.getElementById('file-input').click()">Select STL File</button>
            <p id="file-name"></p>
        </div>
        
        <div id="error-message"></div>
        
        <div class="loading" id="loading">
            <div class="spinner"></div>
            <p>Processing your STL file. This may take a moment...</p>
        </div>
        
        <div id="preview-section" style="display: none;">
            <h2>Preview Sliced Parts</h2>
            <div class="preview-container" id="preview-container">
                <!-- Preview boxes will be generated here -->
            </div>
            <div class="download-all">
                <button id="download-all-btn" disabled>Download All Parts as ZIP</button>
            </div>
        </div>
    </div>

    <!-- Import Three.js and required libraries -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.7.1/jszip.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>

    <!-- STL Loader - explicitly imported to make sure it's available -->
    <script>
        // STLLoader code from Three.js examples (r128)
        THREE.STLLoader = function ( manager ) {
            THREE.Loader.call( this, manager );
        };

        THREE.STLLoader.prototype = Object.assign( Object.create( THREE.Loader.prototype ), {

            constructor: THREE.STLLoader,

            load: function ( url, onLoad, onProgress, onError ) {
                var scope = this;
                var loader = new THREE.FileLoader( scope.manager );
                loader.setPath( scope.path );
                loader.setResponseType( 'arraybuffer' );
                loader.setRequestHeader( scope.requestHeader );
                loader.setWithCredentials( scope.withCredentials );
                loader.load( url, function ( text ) {
                    try {
                        onLoad( scope.parse( text ) );
                    }
            
            function downloadAllParts() {
                // Create zip
                const zip = new JSZip();
                
                // Add each part to the zip
                slicedParts.forEach((part, index) => {
                    const exporter = new THREE.STLExporter();
                    const stlString = exporter.parse(part.scene, { binary: false });
                    zip.file(part.name, stlString);
                });
                
                // Generate and download zip
                zip.generateAsync({ type: 'blob' })
                    .then(function(content) {
                        saveAs(content, 'sliced_parts.zip');
                    })
                    .catch(function(error) {
                        showError(`Error creating zip file: ${error.message}`);
                    });
            }
            
            function sliceModel(geometry, filename) {
                // Compute bounding box
                geometry.computeBoundingBox();
                const box = geometry.boundingBox;
                
                // Calculate dimensions
                const size = new THREE.Vector3();
                box.getSize(size);
                
                // Determine slicing axis (we'll use Y-axis)
                const sliceHeight = size.y / 4;
                
                // Create 4 slices
                for (let i = 0; i < 4; i++) {
                    // In a real implementation, we would use CSG to create proper slices
                    // For this simplified version, we'll just create colored boxes to represent slices
                    
                    // Create a box to represent the slice
                    const boxGeometry = new THREE.BoxGeometry(size.x, sliceHeight, size.z);
                    const material = new THREE.MeshStandardMaterial({
                        color: getPartColor(i),
                        metalness: 0.1,
                        roughness: 0.8
                    });
                    
                    // Position the box
                    const mesh = new THREE.Mesh(boxGeometry, material);
                    mesh.position.y = box.min.y + (i * sliceHeight) + (sliceHeight / 2);
                    
                    // Create a scene for this part
                    const scene = new THREE.Scene();
                    scene.background = new THREE.Color(0xf5f5f5);
                    scene.add(mesh);
                    
                    // Add lights
                    const ambientLight = new THREE.AmbientLight(0x888888);
                    scene.add(ambientLight);
                    
                    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
                    directionalLight.position.set(1, 1, 1);
                    scene.add(directionalLight);
                    
                    // Create a part name
                    const baseName = filename.replace(/\.[^/.]+$/, "");
                    const partName = `${baseName}_part${i+1}.stl`;
                    
                    // Store the part
                    slicedParts.push({
                        name: partName,
                        scene: scene,
                        mesh: mesh
                    });
                    
                    // Create a preview box for this part
                    createPreviewBox(i, partName);
                }
            }
        });
    </script>
</body>
</html> catch ( e ) {
                        if ( onError ) {
                            onError( e );
                        } else {
                            console.error( e );
                        }
                        scope.manager.itemError( url );
                    }
                }, onProgress, onError );
            },

            parse: function ( data ) {
                function isBinary( data ) {
                    var expect, face_size, n_faces, reader;
                    reader = new DataView( data );
                    face_size = ( 32 / 8 * 3 ) + ( ( 32 / 8 * 3 ) * 3 ) + ( 16 / 8 );
                    n_faces = reader.getUint32( 80, true );
                    expect = 80 + ( 32 / 8 ) + ( n_faces * face_size );

                    if ( expect === reader.byteLength ) {
                        return true;
                    }

                    // An ASCII STL data must begin with 'solid ' as the first six bytes.
                    // However, ASCII STLs lacking the SPACE after the 'd' are known to be
                    // plentiful.  So, check the first 5 bytes for 'solid'.
                    // Several encodings, such as UTF-8, precede the text with up to 5 bytes:
                    // https://en.wikipedia.org/wiki/Byte_order_mark#Byte_order_marks_by_encoding
                    // Search for "solid" to start anywhere after those prefixes.
                    // US-ASCII ordinal values for 's', 'o', 'l', 'i', 'd'
                    var solid = [ 115, 111, 108, 105, 100 ];
                    for ( var off = 0; off < 5; off ++ ) {
                        // If "solid" text is matched to the current offset, declare it to be an ASCII STL.
                        if ( matchDataViewAt( solid, reader, off ) ) return false;
                    }

                    // Couldn't find "solid" text at the beginning; it is binary STL.
                    return true;
                }

                function matchDataViewAt( query, reader, offset ) {
                    // Check if each byte in query matches the corresponding byte from the current offset
                    for ( var i = 0, il = query.length; i < il; i ++ ) {
                        if ( query[ i ] !== reader.getUint8( offset + i, false ) ) return false;
                    }
                    return true;
                }

                function parseBinary( data ) {
                    var reader = new DataView( data );
                    var faces = reader.getUint32( 80, true );

                    var r, g, b, hasColors = false, colors;
                    var defaultR, defaultG, defaultB, alpha;

                    // process STL header
                    // check for default color in header ("COLOR=rgba" sequence).
                    for ( var index = 0; index < 80 - 10; index ++ ) {
                        if ( ( reader.getUint32( index, false ) == 0x434F4C4F /*COLO*/ ) &&
                            ( reader.getUint8( index + 4 ) == 0x52 /*'R'*/ ) &&
                            ( reader.getUint8( index + 5 ) == 0x3D /*'='*/ ) ) {
                            hasColors = true;
                            colors = new Float32Array( faces * 3 * 3 );

                            defaultR = reader.getUint8( index + 6 ) / 255;
                            defaultG = reader.getUint8( index + 7 ) / 255;
                            defaultB = reader.getUint8( index + 8 ) / 255;
                            alpha = reader.getUint8( index + 9 ) / 255;
                        }
                    }

                    var dataOffset = 84;
                    var faceLength = 12 * 4 + 2;

                    var geometry = new THREE.BufferGeometry();

                    var vertices = new Float32Array( faces * 3 * 3 );
                    var normals = new Float32Array( faces * 3 * 3 );

                    for ( var face = 0; face < faces; face ++ ) {
                        var start = dataOffset + face * faceLength;
                        var normalX = reader.getFloat32( start, true );
                        var normalY = reader.getFloat32( start + 4, true );
                        var normalZ = reader.getFloat32( start + 8, true );

                        if ( hasColors ) {
                            var packedColor = reader.getUint16( start + 48, true );

                            if ( ( packedColor & 0x8000 ) === 0 ) {
                                // facet has its own unique color
                                r = ( packedColor & 0x1F ) / 31;
                                g = ( ( packedColor >> 5 ) & 0x1F ) / 31;
                                b = ( ( packedColor >> 10 ) & 0x1F ) / 31;
                            } else {
                                r = defaultR;
                                g = defaultG;
                                b = defaultB;
                            }
                        }

                        for ( var i = 1; i <= 3; i ++ ) {
                            var vertexstart = start + i * 12;
                            var componentIdx = ( face * 3 * 3 ) + ( ( i - 1 ) * 3 );

                            vertices[ componentIdx ] = reader.getFloat32( vertexstart, true );
                            vertices[ componentIdx + 1 ] = reader.getFloat32( vertexstart + 4, true );
                            vertices[ componentIdx + 2 ] = reader.getFloat32( vertexstart + 8, true );

                            normals[ componentIdx ] = normalX;
                            normals[ componentIdx + 1 ] = normalY;
                            normals[ componentIdx + 2 ] = normalZ;

                            if ( hasColors ) {
                                colors[ componentIdx ] = r;
                                colors[ componentIdx + 1 ] = g;
                                colors[ componentIdx + 2 ] = b;
                            }
                        }
                    }

                    geometry.setAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );
                    geometry.setAttribute( 'normal', new THREE.BufferAttribute( normals, 3 ) );

                    if ( hasColors ) {
                        geometry.setAttribute( 'color', new THREE.BufferAttribute( colors, 3 ) );
                        geometry.hasColors = true;
                        geometry.alpha = alpha;
                    }

                    return geometry;
                }

                function parseASCII( data ) {
                    var geometry = new THREE.BufferGeometry();
                    var patternSolid = /solid([\s\S]*?)endsolid/g;
                    var patternFace = /facet([\s\S]*?)endfacet/g;
                    var faceCounter = 0;

                    var patternFloat = /[\s]+([+-]?(?:\d*)(?:\.\d*)?(?:[eE][+-]?\d+)?)/.source;
                    var patternVertex = new RegExp( 'vertex' + patternFloat + patternFloat + patternFloat, 'g' );
                    var patternNormal = new RegExp( 'normal' + patternFloat + patternFloat + patternFloat, 'g' );

                    var vertices = [];
                    var normals = [];

                    var normal = new THREE.Vector3();

                    var result;

                    var groupCount = 0;
                    var startVertex = 0;
                    var endVertex = 0;

                    while ( ( result = patternSolid.exec( data ) ) !== null ) {
                        var solid = result[ 0 ];

                        while ( ( result = patternFace.exec( solid ) ) !== null ) {
                            var vertexCountPerFace = 0;
                            var normalCountPerFace = 0;
                            var text = result[ 0 ];

                            while ( ( result = patternNormal.exec( text ) ) !== null ) {
                                normal.x = parseFloat( result[ 1 ] );
                                normal.y = parseFloat( result[ 2 ] );
                                normal.z = parseFloat( result[ 3 ] );
                                normalCountPerFace ++;
                            }

                            while ( ( result = patternVertex.exec( text ) ) !== null ) {
                                vertices.push( parseFloat( result[ 1 ] ), parseFloat( result[ 2 ] ), parseFloat( result[ 3 ] ) );
                                normals.push( normal.x, normal.y, normal.z );
                                vertexCountPerFace ++;
                                endVertex ++;
                            }

                            // every face have to own ONE valid normal
                            if ( normalCountPerFace !== 1 ) {
                                console.error( 'STLLoader: Something isn\'t right with the normal of face number ' + faceCounter );
                            }

                            // each face have to own THREE valid vertices
                            if ( vertexCountPerFace !== 3 ) {
                                console.error( 'STLLoader: Something isn\'t right with the vertices of face number ' + faceCounter );
                            }

                            faceCounter ++;
                        }

                        groupCount ++;
                    }

                    geometry.setAttribute( 'position', new THREE.Float32BufferAttribute( vertices, 3 ) );
                    geometry.setAttribute( 'normal', new THREE.Float32BufferAttribute( normals, 3 ) );

                    return geometry;
                }

                function ensureString( buffer ) {
                    if ( typeof buffer !== 'string' ) {
                        // FIX: Replace LoaderUtils with TextDecoder
                        return new TextDecoder().decode(new Uint8Array(buffer));
                    }

                    return buffer;
                }

                function ensureBinary( buffer ) {
                    if ( typeof buffer === 'string' ) {
                        var array_buffer = new Uint8Array( buffer.length );
                        for ( var i = 0; i < buffer.length; i ++ ) {
                            array_buffer[ i ] = buffer.charCodeAt( i ) & 0xff; // implicitly assumes little-endian
                        }
                        return array_buffer.buffer || array_buffer;
                    } else {
                        return buffer;
                    }
                }

                // start

                var binData = ensureBinary( data );

                return isBinary( binData ) ? parseBinary( binData ) : parseASCII( ensureString( data ) );

            }

        } );
    </script>

    <!-- Updated STL Exporter that works with BufferGeometry directly -->
    <script>
        // Modified STLExporter for Three.js r128+ (without THREE.Geometry dependency)
        THREE.STLExporter = function () {};

        THREE.STLExporter.prototype = {

            constructor: THREE.STLExporter,

            parse: function ( scene, options ) {

                if ( options === undefined ) options = {};

                var binary = options.binary !== undefined ? options.binary : false;

                //

                var objects = [];
                var triangles = 0;

                scene.traverse( function ( object ) {

                    if ( object.isMesh ) {

                        var geometry = object.geometry;

                        if ( geometry.isBufferGeometry ) {
                            // Get position attribute of buffer geometry
                            const position = geometry.getAttribute('position');
                            const normal = geometry.getAttribute('normal');
                            
                            // Count triangles
                            triangles += position.count / 3;

                            objects.push({
                                geometry: geometry,
                                matrixWorld: object.matrixWorld
                            });
                        }

                    }

                } );

                if ( binary ) {

                    var offset = 80; // skip header
                    var bufferLength = triangles * 2 + triangles * 3 * 4 * 4 + 80 + 4;
                    var arrayBuffer = new ArrayBuffer( bufferLength );
                    var output = new DataView( arrayBuffer );
                    output.setUint32( offset, triangles, true ); offset += 4;

                    for ( var i = 0, il = objects.length; i < il; i ++ ) {

                        var object = objects[ i ];
                        var matrixWorld = object.matrixWorld;
                        var geometry = object.geometry;
                        
                        // Get position and normal attributes
                        var position = geometry.getAttribute('position');
                        var normal = geometry.getAttribute('normal');
                        
                        // Temporary vectors for calculations
                        const vA = new THREE.Vector3();
                        const vB = new THREE.Vector3();
                        const vC = new THREE.Vector3();
                        const normalVector = new THREE.Vector3();

                        // Process each triangle
                        for (let j = 0; j < position.count; j += 3) {
                            // Get vertices for this triangle
                            vA.fromBufferAttribute(position, j);
                            vB.fromBufferAttribute(position, j + 1);
                            vC.fromBufferAttribute(position, j + 2);
                            
                            // Transform to world space
                            vA.applyMatrix4(matrixWorld);
                            vB.applyMatrix4(matrixWorld);
                            vC.applyMatrix4(matrixWorld);
                            
                            // Calculate normal if not provided
                            if (normal) {
                                normalVector.fromBufferAttribute(normal, j);
                                normalVector.transformDirection(matrixWorld);
                            } else {
                                // Calculate normal from vertices
                                const cb = new THREE.Vector3().subVectors(vC, vB);
                                const ab = new THREE.Vector3().subVectors(vA, vB);
                                normalVector.crossVectors(cb, ab).normalize();
                            }
                            
                            // Write normal
                            output.setFloat32(offset, normalVector.x, true); offset += 4;
                            output.setFloat32(offset, normalVector.y, true); offset += 4;
                            output.setFloat32(offset, normalVector.z, true); offset += 4;
                            
                            // Write vertices
                            output.setFloat32(offset, vA.x, true); offset += 4;
                            output.setFloat32(offset, vA.y, true); offset += 4;
                            output.setFloat32(offset, vA.z, true); offset += 4;
                            
                            output.setFloat32(offset, vB.x, true); offset += 4;
                            output.setFloat32(offset, vB.y, true); offset += 4;
                            output.setFloat32(offset, vB.z, true); offset += 4;
                            
                            output.setFloat32(offset, vC.x, true); offset += 4;
                            output.setFloat32(offset, vC.y, true); offset += 4;
                            output.setFloat32(offset, vC.z, true); offset += 4;
                            
                            // Attribute byte count
                            output.setUint16(offset, 0, true); offset += 2;
                        }
                    }

                    return output;

                } else {

                    var output = '';
                    output += 'solid exported\n';

                    for (var i = 0, il = objects.length; i < il; i++) {
                        var object = objects[i];
                        var matrixWorld = object.matrixWorld;
                        var geometry = object.geometry;
                        
                        // Get position and normal attributes
                        var position = geometry.getAttribute('position');
                        var normal = geometry.getAttribute('normal');
                        
                        // Temporary vectors for calculations
                        const vA = new THREE.Vector3();
                        const vB = new THREE.Vector3();
                        const vC = new THREE.Vector3();
                        const normalVector = new THREE.Vector3();

                        // Process each triangle
                        for (let j = 0; j < position.count; j += 3) {
                            // Get vertices for this triangle
                            vA.fromBufferAttribute(position, j);
                            vB.fromBufferAttribute(position, j + 1);
                            vC.fromBufferAttribute(position, j + 2);
                            
                            // Transform to world space
                            vA.applyMatrix4(matrixWorld);
                            vB.applyMatrix4(matrixWorld);
                            vC.applyMatrix4(matrixWorld);
                            
                            // Calculate normal if not provided
                            if (normal) {
                                normalVector.fromBufferAttribute(normal, j);
                                normalVector.transformDirection(matrixWorld);
                            } else {
                                // Calculate normal from vertices
                                const cb = new THREE.Vector3().subVectors(vC, vB);
                                const ab = new THREE.Vector3().subVectors(vA, vB);
                                normalVector.crossVectors(cb, ab).normalize();
                            }
                            
                            // Write facet
                            output += '\tfacet normal ' + normalVector.x + ' ' + normalVector.y + ' ' + normalVector.z + '\n';
                            output += '\t\touter loop\n';
                            
                            // Write vertices
                            output += '\t\t\tvertex ' + vA.x + ' ' + vA.y + ' ' + vA.z + '\n';
                            output += '\t\t\tvertex ' + vB.x + ' ' + vB.y + ' ' + vB.z + '\n';
                            output += '\t\t\tvertex ' + vC.x + ' ' + vC.y + ' ' + vC.z + '\n';
                            
                            output += '\t\tendloop\n';
                            output += '\tendfacet\n';
                        }
                    }

                    output += 'endsolid exported\n';

                    return output;
                }
            }
        };
    </script>

    <script>
        // Main application script
        document.addEventListener('DOMContentLoaded', function() {
            // Initialize application
            const fileInput = document.getElementById('file-input');
            const dropArea = document.getElementById('drop-area');
            const fileName = document.getElementById('file-name');
            const loading = document.getElementById('loading');
            const previewSection = document.getElementById('preview-section');
            const previewContainer = document.getElementById('preview-container');
            const downloadAllBtn = document.getElementById('download-all-btn');
            const errorMessage = document.getElementById('error-message');
            
            // Store original model and sliced parts
            let originalModel = null;
            let slicedParts = [];
            
            // Initialize event listeners
            fileInput.addEventListener('change', function(e) {
                if (e.target.files.length > 0) {
                    const file = e.target.files[0];
                    handleFile(file);
                }
            });
            
            // Drag and drop events
            ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
                dropArea.addEventListener(eventName, preventDefaults, false);
            });
            
            ['dragenter', 'dragover'].forEach(eventName => {
                dropArea.addEventListener(eventName, highlight, false);
            });
            
            ['dragleave', 'drop'].forEach(eventName => {
                dropArea.addEventListener(eventName, unhighlight, false);
            });
            
            dropArea.addEventListener('drop', (e) => {
                const file = e.dataTransfer.files[0];
                if (file && file.name.toLowerCase().endsWith('.stl')) {
                    handleFile(file);
                } else {
                    showError('Please drop a valid STL file.');
                }
            });
            
            // Download all button
            downloadAllBtn.addEventListener('click', downloadAllParts);
            
            function preventDefaults(e) {
                e.preventDefault();
                e.stopPropagation();
            }
            
            function highlight() {
                dropArea.style.borderColor = '#4CAF50';
            }
            
            function unhighlight() {
                dropArea.style.borderColor = '#ccc';
            }
            
            function showError(message) {
                errorMessage.textContent = message;
                errorMessage.style.display = 'block';
                loading.style.display = 'none';
            }
            
            function hideError() {
                errorMessage.style.display = 'none';
            }
            
            function handleFile(file) {
                // Clear previous state
                hideError();
                previewSection.style.display = 'none';
                previewContainer.innerHTML = '';
                slicedParts = [];
                
                // Show file name and loading indicator
                fileName.textContent = `Selected file: ${file.name}`;
                loading.style.display = 'block';
                
                // Read file
                const reader = new FileReader();
                reader.onload = function(e) {
                    try {
                        processSTL(e.target.result, file.name);
                    } catch (error) {
                        showError(`Error processing STL file: ${error.message}`);
                        console.error(error);
                    }
                };
                reader.onerror = function() {
                    showError('Error reading file.');
                };
                reader.readAsArrayBuffer(file);
            }
            
            function processSTL(buffer, filename) {
                // Parse STL
                const loader = new THREE.STLLoader();
                
                try {
                    const geometry = loader.parse(buffer);
                    originalModel = geometry;
                    
                    // Slice the model
                    sliceModel(geometry, filename);
                    
                    // Hide loading indicator
                    loading.style.display = 'none';
                    
                    // Show preview section
                    previewSection.style.display = 'block';
                    
                    // Enable download all button
                    downloadAllBtn.disabled = false;
                } catch (error) {
                    showError(`Error parsing STL file: ${error.message}`);
                    console.error(error);
                }
            }
            
            function createPreviewBox(index, partName) {
                // Create a div for this preview
                const previewBox = document.createElement('div');
                previewBox.className = 'preview-box';
                previewBox.innerHTML = `
                    <h3>Part ${index + 1}</h3>
                    <canvas id="canvas-${index}" class="preview-canvas"></canvas>
                    <button class="download-btn" data-index="${index}">Download Part ${index + 1}</button>
                `;
                
                // Add to container
                previewContainer.appendChild(previewBox);
                
                // Set up renderer
                const canvas = document.getElementById(`canvas-${index}`);
                const renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true });
                renderer.setSize(canvas.clientWidth, canvas.clientHeight);
                
                // Set up camera
                const camera = new THREE.PerspectiveCamera(45, canvas.clientWidth / canvas.clientHeight, 0.1, 1000);
                camera.position.set(50, 50, 100);
                camera.lookAt(0, 0, 0);
                
                // Render the scene
                renderer.render(slicedParts[index].scene, camera);
                
                // Add download event listener
                const downloadBtn = previewBox.querySelector('.download-btn');
                downloadBtn.addEventListener('click', () => {
                    downloadPart(index);
                });
            }
            
            function getPartColor(index) {
                const colors = [
                    0x4CAF50, // Green
                    0x2196F3, // Blue
                    0xFF9800, // Orange
                    0xE91E63  // Pink
                ];
                return colors[index % colors.length];
            }
            
            function downloadPart(index) {
                const part = slicedParts[index];
                
                // Use our updated STLExporter to export the part
                const exporter = new THREE.STLExporter();
                const stlString = exporter.parse(part.scene, { binary: false });
                
                // Create blob and download
                const blob = new Blob([stlString], { type: 'application/octet-stream' });
                saveAs(blob, part.name);
            }
