// Complete emotion wheel data exactly matching the provided structure
const emotionWheelData = {
    // Each section contains: emoji, main emotion, middle emotions, and outer emotions
    "Happy": {
        emoji: "😀",
        color: "#FFE680",
        startAngle: 0,
        endAngle: 90,
        middleEmotions: [
            {name: "Playful", outerEmotions: ["Aroused", "Cheeky"]},
            {name: "Content", outerEmotions: ["Free", "Joyful"]},
            {name: "Interested", outerEmotions: ["Inquisitive", "Curious"]},
            {name: "Proud", outerEmotions: ["Successful", "Confident"]},
            {name: "Accepted", outerEmotions: ["Respected", "Valued"]},
            {name: "Powerful", outerEmotions: ["Courageous", "Creative"]},
            {name: "Peaceful", outerEmotions: ["Loving", "Thankful"]},
            {name: "Trusting", outerEmotions: ["Sensitive", "Intimate"]},
            {name: "Optimistic", outerEmotions: ["Hopeful", "Inspired"]}
        ]
    },
    "Surprised": {
        emoji: "😲",
        color: "#DDA0DD",
        startAngle: 90,
        endAngle: 135,
        middleEmotions: [
            {name: "Startled", outerEmotions: ["Shocked", "Dismayed"]},
            {name: "Confused", outerEmotions: ["Disillusioned", "Perplexed"]},
            {name: "Amazed", outerEmotions: ["Awe", "Astonished"]},
            {name: "Excited", outerEmotions: ["Eager", "Energetic"]}
        ]
    },
    "Disgusted": {
        emoji: "🤢",
        color: "#90EE90",
        startAngle: 135,
        endAngle: 180,
        middleEmotions: [
            {name: "Disapproving", outerEmotions: ["Judgmental", "Embarrassed"]},
            {name: "Disappointed", outerEmotions: ["Appalled", "Revolted"]},
            {name: "Awful", outerEmotions: ["Nauseated", "Detestable"]},
            {name: "Avoidance", outerEmotions: ["Hesitant", "Aversion"]}
        ]
    },
    "Bad": {
        emoji: "😐",
        color: "#D3D3D3",
        startAngle: 180,
        endAngle: 225,
        middleEmotions: [
            {name: "Bored", outerEmotions: ["Indifferent", "Apathetic"]},
            {name: "Busy", outerEmotions: ["Pressured", "Rushed"]},
            {name: "Stressed", outerEmotions: ["Overwhelmed", "Out of control"]},
            {name: "Tired", outerEmotions: ["Sleepy", "Unfocussed"]}
        ]
    },
    "Fearful": {
        emoji: "😨",
        color: "#FFB347",
        startAngle: 225,
        endAngle: 270,
        middleEmotions: [
            {name: "Scared", outerEmotions: ["Helpless", "Frightened"]},
            {name: "Anxious", outerEmotions: ["Overwhelmed", "Worried"]},
            {name: "Insecure", outerEmotions: ["Inadequate", "Inferior"]},
            {name: "Weak", outerEmotions: ["Worthless", "Insignificant"]},
            {name: "Rejected", outerEmotions: ["Excluded", "Persecuted"]},
            {name: "Threatened", outerEmotions: ["Nervous", "Exposed"]}
        ]
    },
    "Angry": {
        emoji: "😡",
        color: "#FF6B6B",
        startAngle: 270,
        endAngle: 315,
        middleEmotions: [
            {name: "Let down", outerEmotions: ["Betrayed", "Resentful"]},
            {name: "Humiliated", outerEmotions: ["Disrespected", "Ridiculed"]},
            {name: "Bitter", outerEmotions: ["Indignant", "Violated"]},
            {name: "Mad", outerEmotions: ["Furious", "Jealous"]},
            {name: "Aggressive", outerEmotions: ["Provoked", "Hostile"]},
            {name: "Frustrated", outerEmotions: ["Infuriated", "Annoyed"]},
            {name: "Distant", outerEmotions: ["Withdrawn", "Numb"]},
            {name: "Critical", outerEmotions: ["Skeptical", "Dismissive"]}
        ]
    },
    "Sad": {
        emoji: "😢",
        color: "#87CEEB",
        startAngle: 315,
        endAngle: 360,
        middleEmotions: [
            {name: "Hurt", outerEmotions: ["Embarrassed", "Disappointed"]},
            {name: "Depressed", outerEmotions: ["Inferior", "Empty"]},
            {name: "Guilty", outerEmotions: ["Remorseful", "Ashamed"]},
            {name: "Despair", outerEmotions: ["Grief", "Powerless"]},
            {name: "Vulnerable", outerEmotions: ["Fragile", "Victimized"]},
            {name: "Lonely", outerEmotions: ["Isolated", "Abandoned"]}
        ]
    }
};

// Generate flattened selectable emotions array
let selectableEmotions = [];
let currentAngle = 0;

Object.entries(emotionWheelData).forEach(([mainEmotion, data]) => {
    const sectionSpan = data.endAngle - data.startAngle;
    const totalMiddleEmotions = data.middleEmotions.length;
    const totalOuterEmotions = data.middleEmotions.reduce((sum, mid) => sum + mid.outerEmotions.length, 0);
    
    // Add main emotion (inner ring) - covers entire section
    selectableEmotions.push({
        feeling: mainEmotion,
        emoji: data.emoji,
        color: data.color,
        startAngle: data.startAngle,
        endAngle: data.endAngle,
        ring: "inner"
    });
    
    // Calculate angles for middle and outer emotions
    let middleAngleStep = sectionSpan / totalMiddleEmotions;
    let currentMiddleAngle = data.startAngle;
    
    data.middleEmotions.forEach((middleEmotion, midIndex) => {
        const middleStartAngle = currentMiddleAngle;
        const middleEndAngle = currentMiddleAngle + middleAngleStep;
        
        // Add middle emotion
        selectableEmotions.push({
            feeling: middleEmotion.name,
            color: data.color,
            startAngle: middleStartAngle,
            endAngle: middleEndAngle,
            ring: "middle"
        });
        
        // Add outer emotions for this middle emotion
        const outerAngleStep = middleAngleStep / middleEmotion.outerEmotions.length;
        let currentOuterAngle = middleStartAngle;
        
        middleEmotion.outerEmotions.forEach((outerEmotion, outerIndex) => {
            selectableEmotions.push({
                feeling: outerEmotion,
                color: data.color,
                startAngle: currentOuterAngle,
                endAngle: currentOuterAngle + outerAngleStep,
                ring: "outer"
            });
            currentOuterAngle += outerAngleStep;
        });
        
        currentMiddleAngle += middleAngleStep;
    });
});

function createFeelingsWheel() {
    const centerX = 250;
    const centerY = 250;
    const outerRadius = 240;
    const middleRadius = 160;
    const innerRadius = 80;
    const centerRadius = 40;
    
    let svg = '';
    
    // Group emotions by ring
    const innerRingEmotions = selectableEmotions.filter(item => item.ring === "inner");
    const middleRingEmotions = selectableEmotions.filter(item => item.ring === "middle");
    const outerRingEmotions = selectableEmotions.filter(item => item.ring === "outer");
    
    // Draw inner ring with emojis and main categories
    innerRingEmotions.forEach((item) => {
        const startAngle = (item.startAngle * Math.PI) / 180;
        const endAngle = (item.endAngle * Math.PI) / 180;
        const midAngle = (startAngle + endAngle) / 2;
        
        const x1 = centerX + centerRadius * Math.cos(startAngle);
        const y1 = centerY + centerRadius * Math.sin(startAngle);
        const x2 = centerX + innerRadius * Math.cos(startAngle);
        const y2 = centerY + innerRadius * Math.sin(startAngle);
        const x3 = centerX + innerRadius * Math.cos(endAngle);
        const y3 = centerY + innerRadius * Math.sin(endAngle);
        const x4 = centerX + centerRadius * Math.cos(endAngle);
        const y4 = centerY + centerRadius * Math.sin(endAngle);
        
        const largeArcFlag = (item.endAngle - item.startAngle) > 180 ? 1 : 0;
        
        const path = [
            `M ${x1} ${y1}`,
            `L ${x2} ${y2}`,
            `A ${innerRadius} ${innerRadius} 0 ${largeArcFlag} 1 ${x3} ${y3}`,
            `L ${x4} ${y4}`,
            `A ${centerRadius} ${centerRadius} 0 ${largeArcFlag} 0 ${x1} ${y1}`,
            'Z'
        ].join(' ');
        
        // Position for emoji
        const emojiX = centerX + ((centerRadius + 20) / 2) * Math.cos(midAngle);
        const emojiY = centerY + ((centerRadius + 20) / 2) * Math.sin(midAngle);
        
        // Position for text
        const textX = centerX + ((innerRadius - 15) / 2) * Math.cos(midAngle);
        const textY = centerY + ((innerRadius - 15) / 2) * Math.sin(midAngle);
        
        let textRotation = (item.startAngle + item.endAngle) / 2;
        if (textRotation > 90 && textRotation < 270) {
            textRotation = textRotation + 180;
        }
        
        svg += `
            <path d="${path}" fill="${item.color}" stroke="#fff" stroke-width="3" opacity="0.9"
                  class="wheel-segment" data-feeling="${item.feeling}" data-ring="inner"/>
            <text x="${emojiX}" y="${emojiY}" text-anchor="middle" dominant-baseline="central" 
                  font-size="20" pointer-events="none">
                ${item.emoji}
            </text>
            <text x="${textX}" y="${textY}" text-anchor="middle" dominant-baseline="central" 
                  font-size="11" font-weight="bold" fill="#333" pointer-events="none"
                  transform="rotate(${textRotation}, ${textX}, ${textY})">
                ${item.feeling}
            </text>
        `;
    });
    
    // Draw middle ring
    middleRingEmotions.forEach((item) => {
        const startAngle = (item.startAngle * Math.PI) / 180;
        const endAngle = (item.endAngle * Math.PI) / 180;
        const midAngle = (startAngle + endAngle) / 2;
        
        const x1 = centerX + innerRadius * Math.cos(startAngle);
        const y1 = centerY + innerRadius * Math.sin(startAngle);
        const x2 = centerX + middleRadius * Math.cos(startAngle);
        const y2 = centerY + middleRadius * Math.sin(startAngle);
        const x3 = centerX + middleRadius * Math.cos(endAngle);
        const y3 = centerY + middleRadius * Math.sin(endAngle);
        const x4 = centerX + innerRadius * Math.cos(endAngle);
        const y4 = centerY + innerRadius * Math.sin(endAngle);
        
        const largeArcFlag = (endAngle - startAngle) > Math.PI ? 1 : 0;
        
        const path = [
            `M ${x1} ${y1}`,
            `L ${x2} ${y2}`,
            `A ${middleRadius} ${middleRadius} 0 ${largeArcFlag} 1 ${x3} ${y3}`,
            `L ${x4} ${y4}`,
            `A ${innerRadius} ${innerRadius} 0 ${largeArcFlag} 0 ${x1} ${y1}`,
            'Z'
        ].join(' ');
        
        const textX = centerX + ((innerRadius + middleRadius) / 2) * Math.cos(midAngle);
        const textY = centerY + ((innerRadius + middleRadius) / 2) * Math.sin(midAngle);
        
        let textRotation = (item.startAngle + item.endAngle) / 2;
        if (textRotation > 90 && textRotation < 270) {
            textRotation = textRotation + 180;
        }
        
        svg += `
            <path d="${path}" fill="${item.color}" stroke="#fff" stroke-width="2" opacity="0.8"
                  class="wheel-segment" data-feeling="${item.feeling}" data-ring="middle"/>
            <text x="${textX}" y="${textY}" text-anchor="middle" dominant-baseline="central" 
                  font-size="11" font-weight="600" fill="#333" pointer-events="none"
                  transform="rotate(${textRotation}, ${textX}, ${textY})">
                ${item.feeling}
            </text>
        `;
    });
    
    // Draw outer ring
    outerRingEmotions.forEach((item) => {
        const startAngle = (item.startAngle * Math.PI) / 180;
        const endAngle = (item.endAngle * Math.PI) / 180;
        const midAngle = (startAngle + endAngle) / 2;
        
        const x1 = centerX + middleRadius * Math.cos(startAngle);
        const y1 = centerY + middleRadius * Math.sin(startAngle);
        const x2 = centerX + outerRadius * Math.cos(startAngle);
        const y2 = centerY + outerRadius * Math.sin(startAngle);
        const x3 = centerX + outerRadius * Math.cos(endAngle);
        const y3 = centerY + outerRadius * Math.sin(endAngle);
        const x4 = centerX + middleRadius * Math.cos(endAngle);
        const y4 = centerY + middleRadius * Math.sin(endAngle);
        
        const largeArcFlag = (endAngle - startAngle) > Math.PI ? 1 : 0;
        
        const path = [
            `M ${x1} ${y1}`,
            `L ${x2} ${y2}`,
            `A ${outerRadius} ${outerRadius} 0 ${largeArcFlag} 1 ${x3} ${y3}`,
            `L ${x4} ${y4}`,
            `A ${middleRadius} ${middleRadius} 0 ${largeArcFlag} 0 ${x1} ${y1}`,
            'Z'
        ].join(' ');
        
        const textX = centerX + ((middleRadius + outerRadius) / 2) * Math.cos(midAngle);
        const textY = centerY + ((middleRadius + outerRadius) / 2) * Math.sin(midAngle);
        
        let textRotation = (item.startAngle + item.endAngle) / 2;
        if (textRotation > 90 && textRotation < 270) {
            textRotation = textRotation + 180;
        }
        
        svg += `
            <path d="${path}" fill="${item.color}" stroke="#fff" stroke-width="1" opacity="0.7"
                  class="wheel-segment" data-feeling="${item.feeling}" data-ring="outer"/>
            <text x="${textX}" y="${textY}" text-anchor="middle" dominant-baseline="central" 
                  font-size="9" font-weight="500" fill="#333" pointer-events="none"
                  transform="rotate(${textRotation}, ${textX}, ${textY})">
                ${item.feeling}
            </text>
        `;
    });
    
    document.getElementById('feelingsWheel').innerHTML = svg;
    console.log('Complete emotion wheel created:', 
               innerRingEmotions.length, 'main categories,',
               middleRingEmotions.length, 'middle emotions,', 
               outerRingEmotions.length, 'specific emotions');
}

function updateSelectedFeeling() {
    // Normalize wheel rotation
    let normalizedRotation = ((wheelRotation % 360) + 360) % 360;
    
    // Calculate which angle is currently at the top (under the notch)
    let selectionAngle = (360 - normalizedRotation) % 360;
    
    // Find all emotions that could be selected at this angle
    const possibleSelections = selectableEmotions.filter(item => {
        let itemStart = item.startAngle;
        let itemEnd = item.endAngle;
        
        // Handle the 360/0 degree boundary
        if (itemEnd < itemStart) {
            return selectionAngle >= itemStart || selectionAngle < itemEnd;
        } else {
            return selectionAngle >= itemStart && selectionAngle < itemEnd;
        }
    });
    
    // Priority: outer ring > middle ring > inner ring (most specific first)
    let selectedData = null;
    if (possibleSelections.length > 0) {
        selectedData = possibleSelections.find(item => item.ring === "outer") ||
                      possibleSelections.find(item => item.ring === "middle") ||
                      possibleSelections.find(item => item.ring === "inner");
    }
    
    if (selectedData) {
        selectedFeeling = selectedData.feeling;
        document.getElementById('selectedFeeling').textContent = selectedData.feeling;
        document.getElementById('selectedFeeling').style.color = selectedData.color;
        document.getElementById('nextToDetails').disabled = false;
        console.log('Selected:', selectedFeeling, 'from', selectedData.ring, 'ring at angle:', selectionAngle.toFixed(1));
    } else {
        selectedFeeling = null;
        document.getElementById('selectedFeeling').textContent = 'Rotate the wheel to select a feeling';
        document.getElementById('selectedFeeling').style.color = '#667eea';
        document.getElementById('nextToDetails').disabled = true;
        console.log('No emotion selected at angle:', selectionAngle.toFixed(1));
    }
}
