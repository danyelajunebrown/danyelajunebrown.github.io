<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Display Webcam Stream</title>
 
<style>
body {
    margin: 0;
    padding: 0;
    font-family: Arial, sans-serif;
    cursor: none;
    height: 100vh;
    width: 100vw;
    overflow: hidden;
    animation: boatSway 4s ease-in-out infinite;
}

@keyframes boatSway {
    0% { transform: rotate(0deg) translateY(0px); }
    25% { transform: rotate(0.5deg) translateY(-2px); }
    50% { transform: rotate(0deg) translateY(-4px); }
    75% { transform: rotate(-0.5deg) translateY(-2px); }
    100% { transform: rotate(0deg) translateY(0px); }
}

.custom-cursor {
    width: 32px;
    height: 32px;
    position: fixed;
    pointer-events: none;
    z-index: 9999;
    mix-blend-mode: difference;
    display: none;
}
@media (pointer: fine) {
    .custom-cursor { display: block; }
}
.custom-cursor svg {
    width: 100%;
    height: 100%;
    animation: trotAlong 0.6s infinite alternate;
    fill: white;
}
@keyframes trotAlong {
    0% { transform: translateY(0) rotate(-5deg); }
    100% { transform: translateY(-3px) rotate(5deg); }
}

#container {
    margin: 0px auto;
    width: 100vw;
    height: 100vh;
    border: 10px #333 solid;
    position: relative;
    box-sizing: border-box;
}

#videoElement {
    width: 100%;
    height: 100%;
    background-color: #666;
    object-fit: cover;
}

.nav-menu {
    position: fixed;
    top: 0;
    left: 50%;
    transform: translateX(-50%);
    width: 85%;
    padding: 15px 0;
    z-index: 2000;
    display: flex;
    justify-content: space-between;
    align-items: center;
}

.nav-menu a {
    color: white;
    text-decoration: none;
    padding: 10px 20px;
    font-size: 18px;
    border: 2px solid transparent;
    transition: all 0.3s ease;
    cursor: pointer;
}

.nav-menu a:hover {
    border-bottom: 2px solid white;
}

#toolsBtn.active {
    border-bottom: 2px solid white;
}

/* Tools Dropdown Styling */
.tools-dropdown {
    position: fixed;
    padding: 10px 0;
    z-index: 1999;
    display: flex;
    flex-direction: column;
    gap: 10px;
    opacity: 0;
    pointer-events: none;
    transition: opacity 0.3s ease;
}

.tools-dropdown.show {
    opacity: 1;
    pointer-events: all;
}

.tool-link {
    color: white;
    text-decoration: none;
    padding: 10px 20px;
    font-size: 18px;
    text-align: left;
    border: 2px solid transparent;
    transition: border 0.3s ease;
    cursor: pointer;
    white-space: nowrap;
    font-family: Arial, sans-serif;
    display: block;
}

.tools-dropdown:not(.show) .tool-link {
    opacity: 0;
}

.tools-dropdown.show .tool-link {
    opacity: 1;
}

/* Smooth continuous wave - travels from head to tail */
.tools-dropdown.show .tool-link {
    animation: tailSway 2s ease-in-out infinite;
    animation-delay: calc(var(--item-index) * -0.3s);
}

@keyframes whipWave {
    0% {
        opacity: 0;
        transform: translateX(-50px) rotate(-8deg) scale(0.8);
    }
    60% {
        transform: translateX(8px) rotate(3deg) scale(1.05);
    }
    100% {
        opacity: 1;
        transform: translateX(0) rotate(0deg) scale(1);
    }
}

@keyframes tailSway {
    0% {
        transform: translateX(-8px) rotate(-6deg);
    }
    50% {
        transform: translateX(8px) rotate(6deg);
    }
    100% {
        transform: translateX(-8px) rotate(-6deg);
    }
}

.tool-link:hover {
    border-bottom: 2px solid white;
    transform: translateX(5px) scale(1.05);
}

.name-overlay {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    z-index: 1500;
    pointer-events: none;
    width: 500px;
    height: 500px;
    transition: transform 0.15s ease-out;
}

.name-circle {
    width: 100%;
    height: 100%;
    animation: spinCircle 20s linear infinite;
}

@keyframes spinCircle {
    from {
        transform: rotate(0deg);
    }
    to {
        transform: rotate(360deg);
    }
}

.letter {
    position: absolute;
    color: white;
    font-size: 74px;
    font-weight: normal;
    font-family: Arial, sans-serif;
    transition: transform 0.2s ease-out;
    transform-origin: center center;
    will-change: transform;
}

.name-text {
    fill: white;
    font-size: 74px;
    font-weight: normal;
    font-family: Arial, sans-serif;
    letter-spacing: 1.5px;
}

.char {
    transition: all 0.15s ease-out;
}

@keyframes nameGlow {
    0% { 
        filter: drop-shadow(2px 2px 8px rgba(0, 0, 0, 0.8)) drop-shadow(0 0 20px rgba(255, 255, 255, 0.3));
    }
    100% { 
        filter: drop-shadow(2px 2px 8px rgba(0, 0, 0, 0.8)) drop-shadow(0 0 30px rgba(255, 255, 255, 0.5));
    }
}

/* Responsive adjustments */
@media (max-width: 768px) {            
    .nav-menu {
        width: 95%;
    }
    
    .nav-menu a {
        padding: 8px 10px;
        font-size: 16px;
    }
    
    .name-overlay {
        width: 380px;
        height: 380px;
    }
    
    .letter {
        font-size: 56px;
    }
    
    .name-text {
        font-size: 56px;
        letter-spacing: 1px;
    }

    .tools-dropdown {
        padding: 8px 0;
    }

    .tool-link {
        padding: 8px 15px;
        font-size: 16px;
    }
}

@media (max-width: 480px) {
    .nav-menu {
        width: 98%;
    }
    
    .name-overlay {
        width: 280px;
        height: 280px;
    }
    
    .letter {
        font-size: 43px;
    }
    
    .name-text {
        font-size: 43px;
        letter-spacing: 0.8px;
    }

    .nav-menu a {
        padding: 6px 5px;
        font-size: 14px;
    }

    .tool-link {
        padding: 6px 12px;
        font-size: 14px;
    }
}
</style>
</head>
 
<body>
<nav class="nav-menu">
    <a href="bio.html">BIO</a>
    <a href="#" onclick="linkToCV(); return false;">CV</a>
    <a href="projects.html">SETS</a>
    <a href="#" id="toolsBtn" onclick="toggleToolsMenu(); return false;">TOOLS</a>
</nav>

<div class="tools-dropdown" id="toolsDropdown">
    <a href="toolbelt/make-it-cunt/index.html" class="tool-link" style="--item-index: 0;">Make It Cunt</a>
    <a href="toolbelt/plycutter/index.html" class="tool-link" style="--item-index: 1;">Plycutter</a>
    <a href="toolbelt/stl-buster/index.html" class="tool-link" style="--item-index: 2;">STL Buster</a>
    <a href="toolbelt/the-feels/index.html" class="tool-link" style="--item-index: 3;">The Feels</a>
    <a href="toolbelt/for-damages/damages.html" class="tool-link" style="--item-index: 4;">For Damages</a>
    <a href="toolbelt/dance-clips/index.html" class="tool-link" style="--item-index: 5;">I'm In Charge of the Girls</a>
</div>

<div class="custom-cursor">
    <svg viewBox="0 0 32 32" xmlns="http://www.w3.org/2000/svg">
        <path d="M16 4C14 4 12 5 11 7L8 12L6 14C5 15 5 17 6 18C7 19 9 19 10 18L12 16V24C12 26.2 13.8 28 16 28C18.2 28 20 26.2 20 24V16L22 18C23 19 25 19 26 18C27 17 27 15 26 14L24 12L21 7C20 5 18 4 16 4Z"/>
    </svg>
</div>

<div id="container">
    <video autoplay playsinline muted id="videoElement"></video>
    <div class="name-overlay">
        <svg viewBox="0 0 500 500" class="name-circle" id="nameCircle">
            <defs>
                <path id="circle1" d="M 250, 250 m -123, 0 a 123,123 0 1,1 246,0 a 123,123 0 1,1 -246,0"/>
                <path id="circle2" d="M 250, 250 m -123, 0 a 123,123 0 1,1 246,0 a 123,123 0 1,1 -246,0"/>
                <path id="circle3" d="M 250, 250 m -123, 0 a 123,123 0 1,1 246,0 a 123,123 0 1,1 -246,0"/>
            </defs>
            <text class="name-text" id="name1">
                <textPath href="#circle1" startOffset="2%" spacing="auto">
                    Danyela
                </textPath>
            </text>
            <text class="name-text" id="name2">
                <textPath href="#circle2" startOffset="41%" spacing="auto">
                    June
                </textPath>
            </text>
            <text class="name-text" id="name3">
                <textPath href="#circle3" startOffset="68%" spacing="auto">
                    Brown
                </textPath>
            </text>
        </svg>
    </div>
</div>

<!-- Hidden canvas for capturing screenshots -->
<canvas id="screenshotCanvas" style="display: none;"></canvas>

<script>
// Global variable to store the captured frame
window.capturedCameraFrame = null;

 <!-- Add to index.html -->
<script>
// Browser becomes storage node when page is open
if ('serviceWorker' in navigator) {
  navigator.serviceWorker.register('/mesh-worker.js');
}

// Store 20GB in browser using persistent storage
navigator.storage.persist().then(persistent => {
  if (persistent) {
    console.log('Browser storage persistent - mesh node active');
  }
});
</script>

function captureCurrentFrame() {
    const video = document.getElementById('videoElement');
    const canvas = document.getElementById('screenshotCanvas');
    const ctx = canvas.getContext('2d');
    
    if (video && video.videoWidth > 0 && video.videoHeight > 0) {
        // Set canvas size to match video
        canvas.width = video.videoWidth;
        canvas.height = video.videoHeight;
        
        // Draw the current video frame to canvas
        ctx.drawImage(video, 0, 0);
        
        // Convert to data URL and store globally
        window.capturedCameraFrame = canvas.toDataURL('image/jpeg', 0.8);
        console.log('Screenshot captured successfully');
        return true;
    } else {
        console.log('Video not ready for capture');
        return false;
    }
}

function linkToCV() {
    const currentPage = encodeURIComponent(window.location.href);
    
    // Try to capture current frame before navigating
    const captured = captureCurrentFrame();
    
    if (captured && window.capturedCameraFrame) {
        // Store the image data in sessionStorage instead of URL
        sessionStorage.setItem('capturedFrame', window.capturedCameraFrame);
        sessionStorage.setItem('fromPage', window.location.href);
        window.location.href = 'cv.html';
    } else {
        // Navigate without captured image if capture failed
        window.location.href = 'cv.html';
    }
}

// Toggle tools dropdown menu
function toggleToolsMenu() {
    const dropdown = document.getElementById('toolsDropdown');
    const toolsBtn = document.getElementById('toolsBtn');
    
    if (dropdown.classList.contains('show')) {
        dropdown.classList.remove('show');
        toolsBtn.classList.remove('active');
    } else {
        // Position dropdown below TOOLS button
        const rect = toolsBtn.getBoundingClientRect();
        dropdown.style.left = rect.left + 'px';
        dropdown.style.top = (rect.bottom + 5) + 'px';
        
        dropdown.classList.add('show');
        toolsBtn.classList.add('active');
        
        // Force reflow to trigger animation
        dropdown.offsetHeight;
    }
}

// Close dropdown when clicking outside
document.addEventListener('click', function(event) {
    const dropdown = document.getElementById('toolsDropdown');
    const toolsBtn = document.getElementById('toolsBtn');
    
    if (!dropdown.contains(event.target) && event.target !== toolsBtn) {
        dropdown.classList.remove('show');
        toolsBtn.classList.remove('active');
    }
});

// Auto-start camera when page loads
window.addEventListener('load', async function() {
    const video = document.getElementById('videoElement');
    
    try {
        const stream = await navigator.mediaDevices.getUserMedia({ 
            video: true, 
            audio: false 
        });
        
        video.srcObject = stream;
        
        // Wait for video to be ready, then capture one frame
        video.addEventListener('loadeddata', function() {
            console.log('Video loaded, ready for capture');
            // Capture just one frame after a short delay to ensure video is playing
            setTimeout(() => {
                captureCurrentFrame();
            }, 1000);
        });
        
    } catch (error) {
        console.error('Camera access denied or not available:', error);
    }
});

// Custom cursor for desktop
if (window.matchMedia("(pointer: fine)").matches) {
    document.addEventListener('mousemove', function(e) {
        const cursor = document.querySelector('.custom-cursor');
        cursor.style.left = e.clientX - 16 + 'px';
        cursor.style.top = e.clientY - 16 + 'px';
        
        // Make the whole name circle avoid the cursor
        const nameOverlay = document.querySelector('.name-overlay');
        if (nameOverlay) {
            const rect = nameOverlay.getBoundingClientRect();
            const centerX = rect.left + rect.width / 2;
            const centerY = rect.top + rect.height / 2;
            
            const mouseX = e.clientX;
            const mouseY = e.clientY;
            
            // Distance from mouse to circle center
            const dx = centerX - mouseX;
            const dy = centerY - mouseY;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            // Influence radius - circle reacts within 200px
            const influenceRadius = 200;
            
            if (distance < influenceRadius) {
                // Push away (90% displacement = 1.9x multiplier)
                const pushStrength = (1 - distance / influenceRadius) * 1.9;
                
                // Normalize direction
                const angle = Math.atan2(dy, dx);
                
                // Push distance
                const pushDistance = 80 * pushStrength;
                const pushX = Math.cos(angle) * pushDistance;
                const pushY = Math.sin(angle) * pushDistance;
                
                nameOverlay.style.transform = `translate(calc(-50% + ${pushX}px), calc(-50% + ${pushY}px))`;
            } else {
                // Return to center
                nameOverlay.style.transform = 'translate(-50%, -50%)';
            }
        }
    });
}

// Generate letters on circle with cursor dodge effect
window.addEventListener('load', function() {
    const nameCircle = document.getElementById('nameCircle');
    const centerX = 250;
    const centerY = 250;
    const radius = 123;
    
    const words = [
        { text: 'Danyela', startAngle: 10 },
        { text: 'June', startAngle: 140 },
        { text: 'Brown', startAngle: 240 }
    ];
    
    const letters = [];
    
    // Create letters for each word
    words.forEach(word => {
        const letterSpacing = 18; // degrees between letters
        word.text.split('').forEach((char, i) => {
            const angle = word.startAngle + (i * letterSpacing);
            const radian = (angle - 90) * (Math.PI / 180);
            
            const x = centerX + radius * Math.cos(radian);
            const y = centerY + radius * Math.sin(radian);
            
            const letter = document.createElement('div');
            letter.className = 'letter';
            letter.textContent = char;
            letter.style.left = x + 'px';
            letter.style.top = y + 'px';
            letter.style.transform = `translate(-50%, -50%) rotate(${angle}deg)`;
            
            nameCircle.appendChild(letter);
            
            letters.push({
                element: letter,
                originalX: x,
                originalY: y,
                originalRotation: angle,
                currentOffsetX: 0,
                currentOffsetY: 0
            });
        });
    });
 // Add to existing index.html
class BrowserMeshNode {
  constructor() {
    this.peerId = this.generatePeerId();
    this.storage = new IndexedDB('mesh-documents');
    this.connections = new Map();
    this.setupWebRTC();
  }
  
  async setupWebRTC() {
    // Browser-to-browser connections
    this.peerConnection = new RTCPeerConnection({
      iceServers: [{ urls: 'stun:stun.l.google.com:19302' }]
    });
    
    // Discover nearby browsers on same WiFi
    await this.discoverLocalPeers();
  }
  
  async storeDocument(documentId, fileBlob) {
    // Store in browser's IndexedDB
    await this.storage.put(documentId, fileBlob);
    
    // Replicate to 2 connected peers
    const peers = Array.from(this.connections.values()).slice(0, 2);
    for (const peer of peers) {
      await peer.send('store', { documentId, data: fileBlob });
    }
  }
}
    
    // Cursor dodge effect - only on desktop
    if (window.matchMedia("(pointer: fine)").matches) {
        document.addEventListener('mousemove', function(e) {
            const nameOverlay = document.querySelector('.name-overlay');
            const overlayRect = nameOverlay.getBoundingClientRect();
            const nameCircleEl = document.getElementById('nameCircle');
            const circleRect = nameCircleEl.getBoundingClientRect();
            
            // Account for the spinning circle's rotation
            const computedStyle = window.getComputedStyle(nameCircleEl);
            const transform = computedStyle.transform;
            
            // Get cursor position relative to page center
            const cursorX = e.clientX;
            const cursorY = e.clientY;
            
            letters.forEach(letterData => {
                const letterRect = letterData.element.getBoundingClientRect();
                const letterCenterX = letterRect.left + letterRect.width / 2;
                const letterCenterY = letterRect.top + letterRect.height / 2;
                
                // Calculate distance from cursor to letter
                const dx = letterCenterX - cursorX;
                const dy = letterCenterY - cursorY;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                const repelRadius = 80; // pixels
                
                if (distance < repelRadius && distance > 0) {
                    // Calculate repulsion force
                    const force = (repelRadius - distance) / repelRadius;
                    const pushX = (dx / distance) * force * 30;
                    const pushY = (dy / distance) * force * 30;
                    
                    letterData.currentOffsetX = pushX;
                    letterData.currentOffsetY = pushY;
                    
                    letterData.element.style.transform = 
                        `translate(calc(-50% + ${pushX}px), calc(-50% + ${pushY}px)) rotate(${letterData.originalRotation}deg)`;
                } else {
                    // Return to original position
                    letterData.currentOffsetX = 0;
                    letterData.currentOffsetY = 0;
                    
                    letterData.element.style.transform = 
                        `translate(-50%, -50%) rotate(${letterData.originalRotation}deg)`;
                }
            });
        });
    }
});
</script>
</body>
</html>

<!-- Trigger rebuild -->


